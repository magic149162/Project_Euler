def decorator(f):
    print("Enter decorator")
    
    def wrapper(arg):
        wrapper.counter+=1
        print("Enter wrapper!")
        print wrapper.counter
        return f(arg)
    wrapper.counter=0
    return wrapper;

@decorator
def Function(arg):
    print "Enter Function,arg=",arg

print Function.__closure__
print type(Function.__closure__[0])
print Function.__closure__[0].cell_contents
#print repr(decorator)
#print repr(decorator(Function))
#print repr(Function)

Function(1)
Function(100)

#demonstration on decorated class
class myDecorator(object):

    def __init__(self, f):
        print "inside myDecorator.__init__()"
        self.f = f

    def __call__(self):
        print "inside myDecorator.__call__()"
        self.f()

@myDecorator
def aFunction():
    print "inside aFunction()"

print "Finished decorating aFunction()"

print "Now we will call the decorated function:"
aFunction()

#demonstration on decorated function
def entryExit(f):
    def new_f():
        print "Entering", f.__name__
        f()
        print "Exited", f.__name__
    return new_f

@entryExit
def func1():
    print "inside func1()"

func1()



def enhanced(meth):
    def new(self, y):
        print "I am enhanced"
        return meth(self, y)
    return new
class C:
    def bar(self, x):
        print "some method says:", x
    bar = enhanced(bar)
C().bar(7)



def say(worker):
    print 'I am worker %s' % worker
    def dec(fn):
        def wraped(*argv,**kwgs):
            print 'staring..'
            fn(*argv,**kwgs)
            print 'end.'
        return wraped
    return dec

@say("decorator")
def main(n):
    for i in range(n):
        print i*2

if __name__ == "__main__":
    main(10)

